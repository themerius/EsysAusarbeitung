<html><head><title>ESYS</title><style type="text/css">ol{margin:0;padding:0}.c13{list-style-type:decimal;margin:0;padding:0}.c0{padding-left:0pt;direction:ltr;margin-left:36pt}.c11{list-style-type:disc;margin:0;padding:0}.c12{max-width:508pt;background-color:#ffffff;padding:43.7pt 43.7pt 43.7pt 43.7pt}.c5{color:#1155cc;text-decoration:underline}.c9{color:inherit;text-decoration:inherit}.c2{direction:ltr;margin-left:36pt}.c1{height:18pt;direction:ltr}.c15{color:#009933;background-color:#ffffff}.c10{font-weight:bold}.c7{font-style:italic}.c3{direction:ltr}.c16{font-family:"Courier New"}.c14{margin-left:54pt}.c8{margin-left:18pt}.c4{height:11pt}.c6{margin-left:34.5pt}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Arial";padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#666666;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:10pt;font-family:"Arial";padding-bottom:2pt}</style></head><body class="c12"><h1 class="c1"><a name="h.ytn0txyu13hj"></a></h1><p class="c3 c8"><span class="c5"><a class="c9" href="#h.7r0qyqe2ek34">Vorwort</a></span></p><p class="c3 c8"><span class="c5"><a class="c9" href="#h.2izi2w3k7sz0">Interpretierte Sprachen und Realzeit</a></span></p><p class="c2"><span class="c5"><a class="c9" href="#h.6ng1wyu6xr1r">Definitionen</a></span></p><p class="c2"><span class="c5"><a class="c9" href="#h.y2vemi43u9wr">Vorteile von interpretierten Sprachen</a></span></p><p class="c2"><span class="c5"><a class="c9" href="#h.az34sguq1ub8">Nachteile von interpretierten Sprachen</a></span></p><p class="c2"><span class="c5"><a class="c9" href="#h.he19w2vpgfzi">Problematiken im Realzeit-Bereich</a></span></p><p class="c3 c8"><span class="c5"><a class="c9" href="#h.fyv1xcpkqbra">Beispiel Python</a></span></p><p class="c2"><span class="c5"><a class="c9" href="#h.iqt0obegy8l8">Architektur</a></span></p><p class="c2"><span class="c5"><a class="c9" href="#h.e811rnb3jqns">Garbage Collection</a></span></p><p class="c2"><span class="c5"><a class="c9" href="#h.eqz9t3s2se3t">Setup-Szenarien</a></span></p><p class="c3 c14"><span class="c5"><a class="c9" href="#h.e8cqghcl1rgh">Embedded Linux</a></span></p><p class="c3 c14"><span class="c5"><a class="c9" href="#h.z5wzxjkvsq43">python-on-a-chip</a></span></p><p class="c2"><span class="c5"><a class="c9" href="#h.nnr32lzcb28v">Realzeitf&auml;higkeit</a></span></p><p class="c3 c8"><span class="c5"><a class="c9" href="#h.hgvj37ly1hh4">Fazit</a></span></p><p class="c3 c8"><span class="c5"><a class="c9" href="#h.c8ysuoby4nd2">Fragen</a></span></p><p class="c3 c8"><span class="c5"><a class="c9" href="#h.saghh5zbyul3">Referenzen</a></span></p><p class="c3 c4"><span></span></p><h1 class="c1"><a name="h.bwp6eesnpua3"></a></h1><p class="c3 c4"><span></span></p><hr style="page-break-before:always;display:none;"><h1 class="c1"><a name="h.y4vr7jx1fk1s"></a></h1><h1 class="c3"><a name="h.7r0qyqe2ek34"></a><span>Vorwort</span></h1><p class="c3"><span>Eingebettete Systeme sind immer leistungsf&auml;higer geworden, mittlerweile gibt es sehr g&uuml;nstige 32-Bit Mikrocontroller-Architekturen mit relativ hohen Taktfrequenzen und dennoch geringem Energieverbrauch. Dadurch ergibt sich die M&ouml;glichkeit gr&ouml;&szlig;ere Betriebssysteme, wie Linux, einzusetzen um somit weniger hardwarenah bzw. abstrakter programmieren zu k&ouml;nnen. Jedoch ist dies f&uuml;r gew&ouml;hnlich mit etwas mehr Overhead bzw. erh&ouml;htem Rechenaufwand verbunden, aber zugleich eleganter und schneller zu entwickeln.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Gerade interpretierte Programmiersprachen sind dazu geschaffen, um schnell eleganten Programmcode zu schreiben, aber meistens leidet darunter die Ausf&uuml;hrungsgeschwindigkeit aufgrund von diversen &ldquo;High-Level&rdquo;-Funktionen. In dieser Ausarbeitung soll gekl&auml;rt werden ob solche Programmiersprachen, insbesondere die Programmiersprache Python, auch zur Realzeitf&auml;higkeit taugen. Dazu werden deren Vor- und Nachteile im Realzeit-Kontext betrachtet und spezielle Problematiken aufgezeigt.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Python ist eine sehr beliebte Sprache geworden und wird mittlerweile auf nahezu jeder Standard-UNIX-Distribution mit ausgeliefert und bietet sehr viele flexible M&ouml;glichkeiten, sowie eine gro&szlig;e Standard-Bibliothek, sowie Erweiterbarkeit via C/C++. Aus diesem Grund bietet sich Python als eine attraktive Sprache f&uuml;r den eingebetteten Bereich an, weshalb in dieser Arbeit Python als n&auml;her beleuchtetes Beispiel herangezogen wird. Der zentrale Punkt der Diskussion ist die Garbage Collection, und welche Rolle diese gerade f&uuml;r harte Echtzeit spielt.</span></p><p class="c3"><span>Interessant sind hier aber auch die verschiedenen M&ouml;glichkeiten, Python auf einem eingebetten System auszuf&uuml;hren.</span></p><p class="c3 c4"><span></span></p><hr style="page-break-before:always;display:none;"><p class="c3 c4"><span></span></p><p class="c3 c4"><span></span></p><h1 class="c3"><a name="h.2izi2w3k7sz0"></a><span>Interpretierte Sprachen und Realzeit</span></h1><h2 class="c3"><a name="h.6ng1wyu6xr1r"></a><span>Definitionen</span></h2><p class="c3"><span>Interpretierte Sprachen sind Programmiersprachen, deren Quellcode zur Laufzeit durch einen Interpreter eingelesen, analysiert und ausgef&uuml;hrt wird. Dadurch erm&ouml;glichen sie ein erleichtertes Programmieren, da sie viel Komplexit&auml;t verstecken und einen h&ouml;heren Abstraktionsgrad erm&ouml;glichen -- so m&uuml;ssen zum Beispiel Zeiger nicht mehr explizit verwaltet werden, oder Objekte werden von einem Garbage Collector automatisch aufger&auml;umt.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Realzeit bedeutet, dass das System innerhalb definierter Zeitspannen zu reagieren hat. Das bedeutet also, dass insbesondere die Software innerhalb dieser Zeitspanne ihre Berechnungen erledigt haben muss.</span></p><p class="c3"><span>Wenn ein System oder Prozess weiche Realzeitanforderungen hat, kann auch mal eine Frist, also die Reaktion war au&szlig;erhalb der Zeitspanne, verpasst werden.</span></p><p class="c3"><span>Hat ein System allerdings harte Echtzeitanforderungen, so darf es um keinen Preis die Frist verpassen, da sonst die Folgen fatal w&auml;ren. Beispielsweise ein Airbag, der erst nach dem Unfall ausl&ouml;st, w&auml;re unbrauchbar.</span></p><p class="c3 c4"><span></span></p><h2 class="c3"><a name="h.y2vemi43u9wr"></a><span>Vorteile von interpretierten Sprachen</span></h2><p class="c3"><span>Vorteile auf interpretierte Sprache allgemein =&gt; Vor- / Nachteil im Realzeit-Bereich?</span></p><p class="c3"><span>unter anderem GC</span></p><p class="c3 c4"><span></span></p><ol class="c11" start="1"><li class="c0"><span>erleichterte Programmierung</span></li></ol><p class="c2"><span>Was interpretierte Sprachen auszeichnet ist ihre Wendigkeit und die daraus resultierende k&uuml;rzere Entwicklungszeit der Software. Somit kann Software schneller und einfacher umgebaut werden, aber auch leichter getestet werden. Daher sind interpretierte Sprachen wunderbar f&uuml;r rapide Entwicklung geeignet, weshalb diese Sprachen gerade im Bereich Web sehr verbreitet sind.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Einer der Gr&uuml;nde ist die dynamische Typisierung, die die meisten interpretierten Sprachen einsetzen: Es muss nicht mehr &uuml;ber alle Typen nachgedacht werden bzw. man f&auml;llt nicht mehr so leicht in diverse Fallen, die durch statische Typisierung entstehen. Ebenso ist es jederzeit m&ouml;glich, die logische Programm-Struktur zu &auml;ndern, da diese erst zur Laufzeit zusammengestellt wird; es lassen sich Variablen, Klassen und Funktionen hinzuf&uuml;gen. (Dadurch entsteht aber auch ein gewisser Overhead, wodurch diese Sprachen deutlich langsamer sein k&ouml;nnen.)</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Es gibt viele komfortable und durch die Sprache vordefinierte (u.U. auch sehr m&auml;chtige) Konstrukte, die es erm&ouml;glichen eleganten Code zu schreiben, welcher kompakt und ausdrucksstark ist. Die Sprache hat somit ihre eigenen Paradigmen, welche eine hohe Abstraktion bieten.</span></p><p class="c2"><span>Dank solcher Abstraktionen, muss sich der Programmierer kaum &nbsp;noch Gedanken &uuml;ber Zeiger und ihre Verwaltung machen, das &uuml;bernimmt alles der Interpreter bzw. die virtuelle Maschine der Sprache.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Kein Compilieren, kein Binden, interaktives Debugging.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Der Programmierer arbeitet also mehr problemorientiert, als an den Problemen mit der Programmiersprache zu k&auml;mpfen.</span></p><p class="c3 c4"><span></span></p><ol class="c11" start="1"><li class="c0"><span>leichte Portierbarkeit</span></li></ol><p class="c2"><span>Interpretierte Sprachen lassen sich relativ leicht auf neue Architekturen portieren, denn lediglich der Interpreter muss angepasst werden, der Quellcode der Programme bleibt unber&uuml;hrt.</span></p><p class="c3 c4"><span></span></p><ol class="c11" start="1"><li class="c0"><span>Garbage Collection</span></li></ol><p class="c2"><span>Die Garbage Collection ist eine der High-Level Abstraktionen die vom Interpreter bzw. der virtuellen Maschine der Programmiersprache angeboten werden. Wenn eine GC angeboten wird, bedeutet das f&uuml;r den Programmierer, dass er sich nicht mehr um die Speicherallokierung und Deallokierung k&uuml;mmern muss. Das minimiert potentielle Fehlerquellen und erh&ouml;ht die Entwicklungsgeschwindigkeit &rarr; mehr Fokus auf das Problem, welches gel&ouml;st werden will.</span></p><p class="c3 c4"><span></span></p><h2 class="c3"><a name="h.az34sguq1ub8"></a><span>Nachteile von interpretierten Sprachen</span></h2><p class="c3"><span>Nachteile auf interpretierte Sprache allgemein =&gt; Vor- / Nachteil im Realzeit-Bereich?</span></p><p class="c3 c4"><span></span></p><p class="c3 c4"><span></span></p><ol class="c11" start="1"><li class="c0"><span>Overhead</span></li></ol><p class="c3 c6"><span>Es kann eine langsamere Ausf&uuml;hrungszeit bei interpretierten Sprachen entstehen durch das h&ouml;here Abstraktionslevel und Vereinfachungen. Der Programmcode muss zur Laufzeit interpretiert bzw. compiliert werden; in regelm&auml;&szlig;igen Abst&auml;nden wird eine Garbage Collection vorgenommen, wodurch der eigentliche Programmablauf unterbrochen oder verlangsamt wird.</span></p><p class="c3 c4 c6"><span></span></p><p class="c3 c6"><span>Abgesehen von dem zus&auml;tzlichen Rechenaufwand gibt es einen Mehrbedarf an Arbeitsspeicher, zum einen ben&ouml;tigt der Interpreter (bzw. die virtuelle Maschine) zus&auml;tzlichen RAM f&uuml;r seinen Programmcode und seine Daten, zum anderen braucht der interpretierte Code ebenfalls mehr Speicher als beispielsweise C-Code.</span></p><p class="c3 c4 c6"><span></span></p><p class="c3 c6"><span>Die Ausf&uuml;hrung mittels des Interpreters f&uuml;hrt zu einer indirekteren Systeminteraktion, die Zugriffe auf das Betriebssystem (&ldquo;Syscalls&rdquo;) sind mit Overhead verbunden, da die Schnittstellen abstrahiert sind und der Interpreter die Aufrufe weiterleiten muss.</span></p><p class="c3 c4"><span></span></p><ol class="c11" start="1"><li class="c0"><span>dynamische Typisierung</span></li></ol><p class="c3 c6"><span>Die dynamische Typisierung kann allerdings auch ein Nachteil sein, da der Typ der Variablen unbekannt ist, was gerade in selten durchlaufenen Programmteilen, die eventuell auch nicht richtig getestet wurden, zu unerwartetem Fehlern f&uuml;hren kann. Die dynamische Typ&uuml;berpr&uuml;fung kostet nat&uuml;rlich auch Rechenaufwand zur Laufzeit, zudem fallen Optimierungsm&ouml;glichkeiten wie das direkte Einf&uuml;gen von Maschinencode statt eines Methoden- oder Funktionsaufrufs weg.</span></p><p class="c3 c4"><span></span></p><h2 class="c3"><a name="h.he19w2vpgfzi"></a><span>Problematiken im Realzeit-Bereich</span></h2><p class="c3"><span>Hard / Soft-Realtime</span></p><p class="c3"><span>Determinismus / WorstCase</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>So lange das System noch nicht an der Auslastungsgrenze ist (CPU-Rechenzeit), sollte es kein Problem darstellen, wenn die Software etwas langsamer l&auml;uft. Es kommt erst dann zu Problemen, wenn harte Echtzeit von N&ouml;ten ist, wenn der Garbage Collector anspringt und das Programm somit ins Stocken ger&auml;t -- zumal der GC nicht unbedingt zu deterministischen Zeiten anspringt, und auch nicht bekannt ist, wie lange er aktiv ist. Es ist somit sehr schwierig ein WortCase-Szenario zu erstellen und es m&uuml;ssen M&ouml;glichkeiten gesucht werden, wie man diese Problematiken in den Griff bekommen kann, so dass auch harte Realzeit realisiert werden kann.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>F&uuml;r Systeme die nur eine weiche Realzeit erfordern, sollten diese Beschr&auml;nkungen eher weniger das Problem sein. Was z.B. bei diversen &ldquo;echtzeit&rdquo; Web-Anwendungen der Fall ist.</span></p><h1 class="c1"><a name="h.19l4h7i9qdj3"></a></h1><hr style="page-break-before:always;display:none;"><h1 class="c1"><a name="h.w5c6a96cccku"></a></h1><h1 class="c3"><a name="h.fyv1xcpkqbra"></a><span>Beispiel Python</span></h1><p class="c3"><span>Python, dessen Name sich von der K&uuml;nstlergruppe Monty Python ableitet, ist um 1990 von dem Niederl&auml;nder Guido von Rossum entwickelt worden. In dieser Sprache wird auf die klare Sprachsyntax und gute Lesbarkeit sehr gro&szlig;en Wert gelegt. Geschaffen wurde die Sprache als Br&uuml;cke zwischen Shell-Skripten und C-Programmen.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Es handelt sich dabei um eine interpretierte, interaktive, Objekt-orientierte und funktionale Sprache, die aber auch ein einfaches Skript sein kann. Es gibt klar definierte Konzepte, wie Module f&uuml;r Namenr&auml;ume, dynamische Typesierung und simple, zugleich m&auml;chtige High-Level-Datenstrukturen wie Listen und Verzeichnisse (Dictionaries.) Zudem ist Python sehr leicht via C/C++ erweiterbar, somit k&ouml;nnen Wrapper um C-Programme gebaut werden, so dass ein erleichterter und komfortabler Zugriff via Python m&ouml;glich wird. So k&ouml;nnen bei Bedarf Programmzeilen in hart optimierten C-Code ausgelagert werden und Python genutzt werden -- gerade im eingebetteten Kontext durchaus ein Vorteil.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Durch die aktive Entwicklergemeinde hat sich eine sehr gro&szlig;e und m&auml;chtige Standard-Bibliothek entwickelt. [pyref &rarr; library.pdf] Was nicht zu untersch&auml;tzen ist, gerade weil dadurch die schon sehr portablen Python-Programme, auf diese Basis zur&uuml;ckgreifen k&ouml;nnen, die ohne Konfiguration auf anderen Systemen vornehmen zu m&uuml;ssen.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Aber Python ist auch sehr leicht &uuml;ber externe Bibliotheken erweiterbar. Zudem gibt es neben der gro&szlig;en Standard-Bibliothek sehr viele Pakete, die via pipy-Index zur Verf&uuml;gung stehen -- dieser Umfasst zur Zeit 21658 Pakete.[Fu&szlig;note auf pypi] Das Python-Ecosystem ist sehr umfassend!</span></p><h2 class="c3"><a name="h.iqt0obegy8l8"></a><span>Architektur</span></h2><p class="c3"><span class="c10">Interpreter</span></p><p class="c3"><span>Die Python-Referenzimplementierung CPython ist in der Programmiersprache C geschrieben. Ein Python-Skript wird &uuml;ber den CPython-Interpreter ausgef&uuml;hrt; der Interpreter stellt alle Funktionalit&auml;t bereit um das Skript &ldquo;just in time&rdquo; auszuf&uuml;hren.</span></p><p class="c3"><span>Module sind einfache *.py Dateien, die mit dem Schl&uuml;sselwort import als Namensraum importiert werden k&ouml;nnen. Es kann dann auf Klassen und Funktionen zugegriffen werden, die sich innerhalb der Datei befinden. Pakete sind Ordner die eine __init__.py und auch wieder Module enthalten. Die Pakete bzw. Module werden vom Interpreter relativ zu seinem Ort wo er von z.B. einer Shell aufgerufen wurde aufgesp&uuml;rt. Der Interpreter sp&uuml;rt aber Pakete/Module auch &uuml;ber die Umgebungsvariable PYTHONPATH auf oder &uuml;ber fest definierte Ordner wo sich systemweite Pakete, wie die Standardbibliothek befinden.</span></p><p class="c3"><span>Der Interpreter unterst&uuml;tzt eine selbst&auml;ndige Speicherverwaltung; eine ausf&uuml;hrliche Erkl&auml;rung findet sich in [Kapitel x].</span></p><p class="c3"><span>In CPython gibt es den General Interpreter Lock (GIL), welcher die CPython Implementierung vereinfacht, indem er nur einen Thread zur gleichen Zeit Python-Bytecode ausf&uuml;hren l&auml;sst. Threading ist durchaus m&ouml;glich, um z.B. Nicht-Blockierende Programmabschnitte zu erm&ouml;glichen -- aber mehrere CPU-Kerne bringen der Anwendung nicht mehr Performanz. [pyref &rarr; reference.pdf S.81]</span></p><p class="c3 c4"><span></span></p><p class="c3"><span class="c10">Syntax</span></p><p class="c3"><span class="c16">pycharm.py als Beispiel importieren</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Es gibt noch eine Besonderheit bei den Python-Objekten: Dort muss explizit der self-Zeiger bei jeder Funktion explizit mit angegeben werden. Was der Python Philosophie &nbsp;&ldquo;Explicit is better than implicit&rdquo; [pyzen] entspricht.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span class="c10">Dokumentation</span></p><p class="c3"><span>Die Dokumentation in Python erfolgt &uuml;ber so genannte Docstrings. Diese Docstrings werden an die Funktions-, Klassenr&uuml;mpfe bzw. Modulr&uuml;mpfe geh&auml;ngt (siehe Syntax-Beispiel.) Die Docstrings k&ouml;nnen w&auml;hrend der Laufzeit mit `funktionsname.__doc__` ausgelesen werden. Mit dem beliebten Dokumentationsgenerator `sphinx` kann aus diesen Docstrings automatisch eine Dokumentation generiert werden.</span></p><p class="c3"><span>Beispiele, wie die Funktion benutzt wird, werden gerne als Doctests innerhalb der Docstrings angegeben.</span></p><p class="c3"><span>wie ist es gedacht? wie funktioniert es?</span></p><p class="c3"><span>was ver&auml;ndet sich im eingebetteten Kontext?</span></p><h2 class="c3"><a name="h.e811rnb3jqns"></a><span>Garbage Collection</span></h2><p class="c3"><span>Garbage Collection (</span><span class="c7">GC</span><span>)</span><span>&nbsp;ist ein Prozess, der nicht mehr ben&ouml;tigter Speicher automatisch freigibt, so dass sich der Programmierer nicht mehr explizit darum k&uuml;mmern muss. Python macht intern in der unteren C-Ebene starken Gebrauch von mallock() und free(), daher braucht Python eine Strategie, um Speicherlecks zu vermeiden und verwendet dazu (a) </span><span class="c7">Referenzz&auml;hlen</span><span>&nbsp;und (b) optional einen GC der </span><span class="c7">Referenzzyklen aufsp&uuml;ren und brechen </span><span>kann. [pyref &rarr; S.81 reference.pdf]</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Erg&auml;nzung: Typen die keine Referenzen auf andere Objekte halten, oder lediglich Referenzen auf atomare Typen haben, m&uuml;ssen keine explizite GC unterst&uuml;tzen. [pyref &rarr; S138 c-api.pdf]</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Python </span><span class="c7">unterscheidet</span><span>&nbsp;zwischen (a) Referenzz&auml;hlen und (b) der automatischen optionalen GC [pyref &rarr; S13 extending.pdf]:</span></p><ol class="c11" start="1"><li class="c0"><span>(a) Referenzz&auml;hlen</span></li></ol><p class="c2"><span>Jedes Python-Objekt h&auml;lt eine Variable, worin die Anzahl der Referenzen gez&auml;hlt wird, die von anderen Objekten in Besitz sind. Wenn eine Referenz auf ein Objekt in Besitz genommen werden will, muss es die Py_INCREF-Methode (Variable hochz&auml;hlen) des Objekts aufrufen werden. Wenn der Besitzer die Referenz verwerfen will, so wird Py_DECREF (Variable runterz&auml;hlen) aufgerufen. Sobald die Z&auml;hlvariable bei Null angekommen ist, wird das Objekt zerst&ouml;rt. Dieses Verhalten ist in der untersten Ebene bzw. C-Ebene der Sprache verdrahtet -- zumindest gilt das f&uuml;r die offizielle CPython-Referenzimplementierung.</span></p><p class="c2"><span>Es gibt auch die M&ouml;glichkeit, dass Referenzen ausgeliehen werden k&ouml;nnen. Wenn das der Fall ist, wird kein Py_DECREF vom Leihenden aufgerufen (die Referenz kann vom Leihenden also nicht zerst&ouml;rt werden.) Vorteil: Der Leihende muss nicht die Verantwortung &uuml;ber die Zerst&ouml;rung der Referenz tragen; Nachteil: Der Leihende l&auml;uft Gefahr schon freiger&auml;umten Speicher zu verwenden.</span></p><ol class="c11" start="1"><li class="c0"><span>(b) Automatische GC</span></li></ol><p class="c2"><span>Das was unter Python als automatischer GC gilt, ist optional und kann zur Lauftzeit deaktiviert werden. Dazu gibt es ein Interface, welches &uuml;ber das `gc`-Modul bereitgestellt wird, wo noch mehr Parameter eingestellt werden k&ouml;nnen, um das GC-Verhalten feinabzustimmen.</span></p><p class="c2"><span>Die automatische GC bietet eine verz&ouml;gerte Erkennung von zyklisch zusammenh&auml;ngenden Garbage-Objekten, eben diese die nicht via Referenzz&auml;hlen aufgesp&uuml;rt werden k&ouml;nnen; z.B. wenn ein Objekt auf sich selbst eine Referenz h&auml;lt.</span></p><p class="c2"><span>Die automatische GC ist also nur eine Erg&auml;nzung zum Referenzz&auml;hlen.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Der automatische, aber optionale, GC sorgt f&uuml;r ein nicht-deterministisches Verhalten (durch die verz&ouml;gerte Erkennung der Zyklen, die irgendwann auftreten kann), was gerade f&uuml;r harte Echtzeitbedingungen zu schwer zu prognostizierender Worst-Case-Analyse f&uuml;hrt. Wenn man den GC deaktiviert, muss jedoch darauf geachtet werden, dass keine Referenz-Zyklen auftreten, was ein potentielles Speicherleck hervorrufen kann. [pyref &rarr; S1084 library.pdf]</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Das Referenzz&auml;hlen kann in eine Worst-Case-Analyse besser aufgenommen werden, da sich das Problem ebenfalls auf der C-Ebene abspielen w&uuml;rde -- und es gibt durchaus realzeitf&auml;hige </span><span class="c7">Dynamic Storage Allocator</span><span>&nbsp;Algorithmen, die wiederum mehr vom Betriebssystem bzw. den verwendeten C-Bibliotheken abh&auml;ngen. Dieses Verhalten sollte und kann auch in die Worst-Case-Berechnungen mit einflie&szlig;en. [malloc]</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Referenzz&auml;hlen ist also durchaus f&uuml;r den harten Echtzeiteinsatz geeignet. Zumal eine Art von GC auch auf eingebetteten Systemen nicht verkehrt ist, da dort Speicherlecks desastr&ouml;s sind in Anbetracht der geringen Speicherressourcen bzw. der einfachen oder nicht vorhandenen Speicherverwaltung des eingebetteten Betriebssystems. [refcount]</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Wenn beim Programmstart lediglich statischer Speicher alloziert wird, so sollte die GC sowieso eine recht untergeordnete Rolle spielen.</span></p><h2 class="c3"><a name="h.eqz9t3s2se3t"></a><span>Setup-Szenarien</span></h2><h3 class="c3"><a name="h.e8cqghcl1rgh"></a><span>Embedded Linux</span></h3><p class="c3"><span>Linux ist ein weit verbreiteter Open-Source Betriebssystem-Kernel. Der Kernel ist sehr flexibel in der Konfiguration, soll hei&szlig;en, er kann vom Supercomputer bis zum kleinen eingebetteten System verwendet werden. Mindestens wird jedoch ein 32-Bit Prozessor vorausgesetzt.</span></p><p class="c3"><span>Der Standardkernel kann lediglich weiche Realzeit garantieren, aber es gibt Projekte die versuchen den Kernel auch fit f&uuml;r harte Realzeit im eingebetteten Kontext zu machen. Beispiele hierf&uuml;r sind RTLinux, &micro;Clinux oder avr32linux. Realtime Linux ist eine Abzweigung des Standardkernel, welcher eine verbesserte Unterbrechbarkeit und hochaufl&ouml;sende Timer bietet; es flie&szlig;en hin und wieder diese Modifikationen auch in den Standardkernel ein. [dipl S.5]</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Im folgenden werden verschiedene Python Implementierungen f&uuml;r (embedded) Linux vorgestellt:</span></p><ol class="c11" start="1"><li class="c0"><span>CPython</span></li></ol><p class="c2"><span>Auf die Implementierung von CPython sind wir schon im Kapitel (Architektur, GC) ausf&uuml;hrlich eingegangen.</span></p><p class="c2"><span>CPython muss gegen die glibc oder uClibc gebaut werden. Selbst wenn viele nicht ben&ouml;tigte Pakete aus der Standardbibliothek entfernt werden, ben&ouml;tigt der Interpreter noch immer mindestens 725 KB. [embeddedlinux Kap. 4.6]</span></p><ol class="c11" start="1"><li class="c0"><span>tinypy</span></li></ol><p class="c2"><span>Ist eine minimalistische Python-Implementierung, die nur 64 KB braucht. [tinypy]</span></p><ol class="c11" start="1"><li class="c0"><span>IronPython</span></li></ol><p class="c3 c6"><span>IronPython ist eine open-source Implementierung von Python f&uuml;r das .NET Framework. Die in C# geschriebene Umgebung kann sowohl .NET- als auch Python-Bibliotheken verwenden und macht es den .NET-Programmiersprachen auf einfache Weise m&ouml;glich Python-Code auszuf&uuml;hren.</span></p><p class="c3 c6"><span>IronPython l&auml;sst sich auf einem (embedded) Linux mittels der Mono Virtual Machine ausf&uuml;hren und bietet gute M&ouml;glichkeiten zum Debuggen. Der Mono Debugger unterst&uuml;tzt Remote-Debugging, wof&uuml;r nur ein kleiner Debug-Server auf dem eingebetteten System notwendig ist, und bietet so eine &Uuml;bersicht der Threads inklusive Stacktraces und Inhalten der Variablen, zudem lassen sich Breakpoints festlegen und die Anweisungen k&ouml;nnen schrittweise durchsprungen werden ([ironpython], Kap. 3).</span></p><p class="c3 c6"><span>Der von IronPython generierte CIL-Bytecode kann als .NET-Assembly gespeichert werden, was ein erneutes Ausf&uuml;hren durch die Virtual Machine um einiges beschleunigt.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Im Zuge der Diplomarbeit von Volker Thoms sind eine Reihe von Python-Modulen f&uuml;r den komfortablen Ger&auml;tezugriff in Verbindung mit einem embedded Linux entstanden bzw. in Zusammenhang gebracht. Es handelt sich dabei um Wrapper f&uuml;r die Unix-Ger&auml;te-Dateien (/dev/*) [dipl]:</span></p><ol class="c11" start="1"><li class="c0"><span>socket: Teil der Standardbibliothek</span></li><li class="c0"><span>pyserial: F&uuml;r serielle Schnittstellen, ein Wrapper um termios.</span></li><li class="c0"><span>py-smbus: Wrapper um /dev/i2c-x</span></li><li class="c0"><span>py-spi: Wrapper um /dev/spidevX.Y. (X=bus, Y=client)</span></li><li class="c0"><span>py-pwm: Generische Pulsweiten Modulations API, die den Hardwarekanal ansprechen kann</span></li><li class="c0"><span>py-softpwm: Software PWM als Kernelmodul, Wrapper um /dev/softpwm [dipl]</span></li></ol><p class="c3 c4"><span></span></p><p class="c3"><span>PyET ist eine Sammlung von Programmen, Modulen und Skripten, welche die Entwicklung von eingebetteten Systemen mit Python vereinfacht. Es existieren beispielsweise Pakete f&uuml;r &ldquo;Background Debug Mode for Motorola processors&rdquo; (PyBDM) und &ldquo;Boundary Scan for IEEE-1149.1 (JTAG) devices&rdquo; (PyBSC), welche von dem PyET-Projekt entwickelt wurden. [pyet]</span></p><h3 class="c3"><a name="h.z5wzxjkvsq43"></a><span>python-on-a-chip</span></h3><p class="c3"><span>Einen sehr spannenden und g&auml;nzlich anderen Ansatz verfolgt das python-on-a-chip-Projekt. Das Projekt entwickelt eine reduzierte Python virtuelle Maschine, die PyMite VM, zugeschnitten auf 8-Bit und gr&ouml;&szlig;ere Mikrocontroller. Es kommt g&auml;nzlich ohne Betriebssystem aus und kann somit direkt auf dem Mikrocontroller arbeiten, mit gleichzeitig geringem Resourcenverbrauch von ca. 64 KB Flash-Speicher und mindestens 4 KB Arbeitsspeicher.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Jedoch gilt zu beachten, dass es sich hierbei um ein reduziertes Python handelt und somit nicht alle Python-Tricks umgesetzt werden k&ouml;nnen. Es kann somit auch nicht auf die normale Python-Standard-Bibliothek gesetzt werden bzw. andere normale Bibliotheken, die das vollst&auml;ndige Python voraussetzen. Der Entwickler muss also auf die Treiber, Bibliotheken und Tools setzen, die das python-on-a-chip-Projekt liefert.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Die VM kann mehrere Threads mit dem Round-Robin Scheduling-Verfahren laufen lassen. Als GC-Methode kommt ein Mark-and-Sweep-Algorithmus zum Einsatz. [p14]</span></p><p class="c3"><span>Die Worst-Case-Ausf&uuml;hrungszeit von Mark-and-Sweep entspricht der quadrierten dynamischen Speichergr&ouml;&szlig;e (Heap). [sweep] Und sobald eine vern&uuml;nftige Worst-Case-Analyse m&ouml;glich ist, kann auch harter Realzeit gen&uuml;ge getan werden -- wenn auch die Analyse mit etwas mehr Aufwand verbunden ist als mit manueller Speicherverwaltung.</span></p><h2 class="c3"><a name="h.nnr32lzcb28v"></a><span>Realzeitf&auml;higkeit</span></h2><p class="c3"><span>besondere Problematiken / Vorteile im eingebetten Kontext</span></p><p class="c3"><span>GC</span></p><p class="c3"><span>Umgang micht Stack (wo werden Variablen gespeichert? &ldquo;Umgehen&rdquo; der Garbage-Collection??)</span></p><h1 class="c1"><a name="h.6xxkfqehcnjx"></a></h1><hr style="page-break-before:always;display:none;"><h1 class="c1"><a name="h.lf0rti9dcfpa"></a></h1><h1 class="c3"><a name="h.hgvj37ly1hh4"></a><span>Fazit</span></h1><p class="c3"><span>Zun&auml;chst wurde ein &Uuml;berblick verschafft, was interpretierte Sprachen &ldquo;Skriptsprachen&rdquo; ausmacht. Der gro&szlig;e Vorteil sind die agile Entwicklung und Nachteil ist die Performanz bzw. das Nicht-deterministische Verhalten, welches gerade durch den Gargabe Collector ausgel&ouml;st wird.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Im Konkreten Beispiel Python sind die Implementeriungsdetails der Sprache zur Sprache gekommen, insbesondere die Details der Referenzimplementierung CPython und ob es m&ouml;glich ist diese Sprache harten Realzeitanforderungen auszusetzen, ohne all zu viel von der agilen und komfortablen Entwicklung zu verlieren. Das h&auml;ngt von zwei Faktoren ab: (1) dem eingesetzen Betriebssystem und (2) ob eine vern&uuml;nftige Worst-Case-Analyse der Spracheigenschaften bzw. Sprachimplementierung, aber insbesondere des eingesetzten Garbage Collection Verfahrens. Es konnte gezeigt werden, dass es durchaus Garbage Collection Verfahren, wie das Referenzz&auml;hlen, gibt, die auch f&uuml;r harte Echtzeit geeigenet sind und CPython setzt dieses Verfahren ein. Wenn ein embedded Linux als Betriebssystem eingesetzt wird, muss jedoch etwas Aufwand getrieben werden, dieses f&uuml;r harte Echtzeit zu r&uuml;sten.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Aber es gibt nicht nur die CPython-Implementeriung sondern auch eine Reihe anderer Python-Interpreter die es sich zum Ziel gesetzt haben minimalere Interpreter zu entwickeln, die insbesondere einen geringen Resourcenverbrauch aufweisen.</span></p><p class="c3"><span>Das python-on-a-chip Projekt sticht heraus, da es den Python Interpreter direkt auf einem Mikrokontroller lauff&auml;hig macht; ganz ohne Betriebssystem. Zudem ist die vom Projekt eingesetze Garbage Collection Worst-Case-analysierbar und somit kann harte Realzeit garantiert werden.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Was aber bei allen Skriptingsprachen gilt ist, dass die Worst-Case-Analyse zur Bestimmung der harten Realzeitanforderungen komplexer ist und einige mehr Fallen existieren.</span></p><p class="c3"><span>Jedoch Fakt ist, dass eine einfachere und schnellere Entwicklung m&ouml;glich ist, die f&uuml;r weiche Realzeitanforderungen mehr als gen&uuml;gt, sofern genug Hardwareressourcen zur Verf&uuml;gung stehen.</span></p><h1 class="c3"><a name="h.c8ysuoby4nd2"></a><span>Fragen</span></h1><ol class="c13" start="1"><li class="c0"><span>was zu interpretierten Sprachen</span></li><li class="c0"><span>was zur GC</span></li><li class="c0"><span>was zu Python</span></li></ol><h1 class="c3"><a name="h.saghh5zbyul3"></a><span>Referenzen</span></h1><p class="c3"><span>[pyref] </span><span class="c5"><a class="c9" href="http://docs.python.org/ftp/python/doc/2.7.3/python-2.7.3-docs-pdf-a4.zip">http://docs.python.org/ftp/python/doc/2.7.3/python-2.7.3-docs-pdf-a4.zip</a></span></p><p class="c3"><span>[malloc] </span><span class="c5"><a class="c9" href="http://pub.mroot.net/Documents/Seminar-Realtime-malloc.pdf">http://pub.mroot.net/Documents/Seminar-Realtime-malloc.pdf</a></span></p><p class="c3"><span>[ironpython] &nbsp;</span><span class="c5"><a class="c9" href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?tp=&amp;arnumber=4976337">http://ieeexplore.ieee.org/xpl/articleDetails.jsp?tp=&amp;arnumber=4976337</a></span><span>&nbsp;</span></p><p class="c3"><span>[dipl] </span><span class="c5"><a class="c9" href="http://elk.informatik.fh-augsburg.de/da/da-49/da-thoms-cc.pdf">http://elk.informatik.fh-augsburg.de/da/da-49/da-thoms-cc.pdf</a></span><span>&nbsp;</span></p><p class="c3"><span>[refcount] Tobias Ritzau, Real-Time Reference Counting</span></p><p class="c3"><span>[embeddedlinux] </span><span class="c5"><a class="c9" href="http://www.kerneltravel.net/downloads/Building.Embedded.Linux.Systems.pdf">http://www.kerneltravel.net/downloads/Building.Embedded.Linux.Systems.pdf</a></span></p><p class="c3"><span>[tinypy] </span><span class="c5"><a class="c9" href="http://code.google.com/p/tinypy/">http://code.google.com/p/tinypy/</a></span></p><p class="c3"><span>[pyet] </span><span class="c5"><a class="c9" href="http://www.nongnu.org/pyet/">http://www.nongnu.org/pyet/</a></span></p><p class="c3"><span>[pyzen] The Zen of Python </span><span class="c5"><a class="c9" href="http://www.python.org/dev/peps/pep-0020/">http://www.python.org/dev/peps/pep-0020/</a></span></p><p class="c3"><span>[sweep] Memory Efficient Hard Real-Time Garbage Collection </span><span class="c15">liu.diva-portal.org/smash/get/diva2:20899/FULLTEXT01</span></p><p class="c3"><span>[p14p] </span><span class="c5"><a class="c9" href="http://code.google.com/p/python-on-a-chip/">http://code.google.com/p/python-on-a-chip/</a></span></p></body></html>