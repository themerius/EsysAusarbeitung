<html><head><title>ESYS</title><style type="text/css">ol{margin:0;padding:0}.c11{max-width:508pt;background-color:#ffffff;padding:43.7pt 43.7pt 43.7pt 43.7pt}.c1{list-style-type:disc;margin:0;padding:0}.c4{color:#1155cc;text-decoration:underline}.c7{color:inherit;text-decoration:inherit}.c6{height:18pt}.c5{margin-left:36pt}.c8{margin-left:18pt}.c2{height:11pt}.c0{direction:ltr}.c3{margin-left:34.5pt}.c10{padding-left:0pt}.c9{font-style:italic}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Arial";padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#666666;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:10pt;font-family:"Arial";padding-bottom:2pt}</style></head><body class="c11"><h1 class="c6 c0"><a name="h.ytn0txyu13hj"></a></h1><p class="c0 c8"><span class="c4"><a class="c7" href="#h.7r0qyqe2ek34">Vorwort</a></span></p><p class="c8 c0"><span class="c4"><a class="c7" href="#h.2izi2w3k7sz0">Interpretierte Sprachen und Realzeit</a></span></p><p class="c5 c0"><span class="c4"><a class="c7" href="#h.6ng1wyu6xr1r">Definitionen</a></span></p><p class="c5 c0"><span class="c4"><a class="c7" href="#h.y2vemi43u9wr">Vorteile von interpretierten Sprachen</a></span></p><p class="c5 c0"><span class="c4"><a class="c7" href="#h.az34sguq1ub8">Nachteile von interpretierten Sprachen</a></span></p><p class="c5 c0"><span class="c4"><a class="c7" href="#h.he19w2vpgfzi">Problematiken im Realzeit-Bereich</a></span></p><p class="c8 c0"><span class="c4"><a class="c7" href="#h.fyv1xcpkqbra">Beispiel Python</a></span></p><p class="c5 c0"><span class="c4"><a class="c7" href="#h.iqt0obegy8l8">Architektur</a></span></p><p class="c5 c0"><span class="c4"><a class="c7" href="#h.e811rnb3jqns">Garbage Collection</a></span></p><p class="c5 c0"><span class="c4"><a class="c7" href="#h.eqz9t3s2se3t">Setup-Szenarien</a></span></p><p class="c5 c0"><span class="c4"><a class="c7" href="#h.nnr32lzcb28v">Realzeitf&auml;higkeit</a></span></p><p class="c8 c0"><span class="c4"><a class="c7" href="#h.yom4vsum15is">Fazit</a></span></p><p class="c8 c0"><span class="c4"><a class="c7" href="#h.saghh5zbyul3">Referenzen</a></span></p><p class="c2 c0"><span></span></p><h1 class="c6 c0"><a name="h.bwp6eesnpua3"></a></h1><p class="c2 c0"><span></span></p><hr style="page-break-before:always;display:none;"><h1 class="c6 c0"><a name="h.y4vr7jx1fk1s"></a></h1><h1 class="c0"><a name="h.7r0qyqe2ek34"></a><span>Vorwort</span></h1><p class="c0"><span>Eingebettete Systeme werden immer leistungsf&auml;higer und dadurch ergibt sich die M&ouml;glichkeit weniger hardwarenah zu programmieren beziehungsweise abstrakter zu werden -- denn dies ist f&uuml;r gew&ouml;hnlich mit etwas Overhead beziehungsweise erh&ouml;htem Rechenaufwand verbunden, aber zugleich eleganter und schneller zu entwickeln.</span></p><p class="c0 c2"><span></span></p><p class="c0"><span>Gerade interpretierte Programmiersprachen sind dazu geschaffen, um schnell eleganten Programmcode zu schreiben, aber meistens leidet darunter die Ausf&uuml;hrungsgeschwindigkeit aufgrund von diversen &ldquo;High-Level&rdquo;-Funktionen.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Ob solche Programmiersprachen auch realzeitf&auml;hig sind, soll in dieser Arbeit gekl&auml;rt werden. Dazu werden deren Vor- und Nachteile im Realzeit-Kontext betrachtet und spezielle Problematiken aufgezeigt.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Python ist eine sehr beliebte Sprache geworden und wird mittlerweile auf nahezu jeder Standard-UNIX-Distribution mit ausgeliefert und bietet sehr viele und flexible M&ouml;glichkeiten, wie eine gro&szlig;e Standard-Bibliothek und Erweiterbarkeit via C/C++ und bietet sich darum als Beispielssprache an. Interessant sind &nbsp;hier auch die verschiedenen M&ouml;glichkeiten, Python auf einem eingebetten System auszuf&uuml;hren.</span></p><p class="c2 c0"><span></span></p><hr style="page-break-before:always;display:none;"><p class="c2 c0"><span></span></p><p class="c2 c0"><span></span></p><h1 class="c0"><a name="h.2izi2w3k7sz0"></a><span>Interpretierte Sprachen und Realzeit</span></h1><h2 class="c0"><a name="h.6ng1wyu6xr1r"></a><span>Definitionen</span></h2><p class="c0"><span>Interpretierte Sprachen sind Programmiersprachen, deren Quellcode zur Laufzeit durch einen Interpreter eingelesen, analysiert und ausgef&uuml;hrt wird. Dadurch erm&ouml;glichen sie ein erleichtertes Programmieren, da sie viel Komplexit&auml;t verstecken und einen h&ouml;heren Abstraktionsgrad erm&ouml;glichen -- so m&uuml;ssen zum Beispiel Zeiger nicht mehr explizit verwaltet werden, oder Objekte werden von einem Garbage Collector automatisch aufger&auml;umt.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Realzeit bedeutet, dass das System innerhalb definierter Zeitspannen zu reagieren hat. Das bedeutet also, dass insbesondere die Software innerhalb dieser Zeitspanne ihre Berechnungen erledigt haben muss.</span></p><p class="c0"><span>Wenn ein System oder Prozess weiche Realzeitanforderungen hat, kann auch mal eine Frist, also die Reaktion war au&szlig;erhalb der Zeitspanne, verpasst werden.</span></p><p class="c0"><span>Hat ein System allerdings harte Echtzeitanforderungen, so darf es um keinen Preis die Frist verpassen, da sonst die Folgen fatal w&auml;ren. Beispielsweise ein Airbag, der erst nach dem Unfall ausl&ouml;st, w&auml;re unbrauchbar.</span></p><p class="c2 c0"><span></span></p><h2 class="c0"><a name="h.y2vemi43u9wr"></a><span>Vorteile von interpretierten Sprachen</span></h2><p class="c0"><span>Vorteile auf interpretierte Sprache allgemein =&gt; Vor- / Nachteil im Realzeit-Bereich?</span></p><p class="c0"><span>unter anderem GC</span></p><p class="c2 c0"><span></span></p><ol class="c1" start="1"><li class="c5 c0 c10"><span>erleichterte Programmierung</span></li></ol><p class="c5 c0"><span>Was interpretierte Sprachen auszeichnet ist ihre Wendigkeit und die daraus resultierende k&uuml;rzere Entwicklungszeit der Software. Somit kann Software schneller und einfacher umgebaut werden, aber auch leichter getestet werden. Daher sind interpretierte Sprachen wunderbar f&uuml;r rapide Entwicklung geeignet, weshalb diese Sprachen gerade im Bereich Web sehr verbreitet sind.</span></p><p class="c5 c2 c0"><span></span></p><p class="c5 c0"><span>Einer der Gr&uuml;nde ist die dynamische Typisierung, die die meisten interpretierten Sprachen einsetzen: Es muss nicht mehr &uuml;ber alle Typen nachgedacht werden bzw. man f&auml;llt nicht mehr so leicht in diverse Fallen, die durch statische Typisierung entstehen. Ebenso ist es jederzeit m&ouml;glich, die logische Programm-Struktur zu &auml;ndern, da diese erst zur Laufzeit zusammengestellt wird; es lassen sich Variablen, Klassen und Funktionen hinzuf&uuml;gen. (Dadurch entsteht aber auch ein gewisser Overhead, wodurch diese Sprachen deutlich langsamer sein k&ouml;nnen.)</span></p><p class="c5 c2 c0"><span></span></p><p class="c5 c0"><span>Es gibt viele komfortable und durch die Sprache vordefinierte (u.U. auch sehr m&auml;chtige) Konstrukte, die es erm&ouml;glichen eleganten Code zu schreiben, welcher kompakt und ausdrucksstark ist. Die Sprache hat somit ihre eigenen Paradigmen, welche eine hohe Abstraktion bieten.</span></p><p class="c5 c0"><span>Dank solcher Abstraktionen, muss sich der Programmierer kaum &nbsp;noch Gedanken &uuml;ber Zeiger und ihre Verwaltung machen, das &uuml;bernimmt alles der Interpreter bzw. die virtuelle Maschine der Sprache.</span></p><p class="c5 c2 c0"><span></span></p><p class="c0 c5"><span>Kein Compilieren, kein Binden, interaktives Debugging.</span></p><p class="c5 c2 c0"><span></span></p><p class="c5 c0"><span>Der Programmierer arbeitet also mehr problemorientiert, als an den Problemen mit der Programmiersprache zu k&auml;mpfen.</span></p><p class="c2 c0"><span></span></p><ol class="c1" start="1"><li class="c5 c0 c10"><span>leichte Portierbarkeit</span></li></ol><p class="c5 c0"><span>Interpretierte Sprachen lassen sich relativ leicht auf neue Architekturen portieren, denn lediglich der Interpreter muss angepasst werden, der Quellcode der Programme bleibt unber&uuml;hrt.</span></p><p class="c2 c0"><span></span></p><ol class="c1" start="1"><li class="c5 c0 c10"><span>Garbage Collection</span></li></ol><p class="c5 c0"><span>Die Garbage Collection ist eine der High-Level Abstraktionen die vom Interpreter bzw. der virtuellen Maschine der Programmiersprache angeboten werden. Wenn eine GC angeboten wird, bedeutet das f&uuml;r den Programmierer, dass er sich nicht mehr um die Speicherallokierung und Deallokierung k&uuml;mmern muss. Das minimiert potentielle Fehlerquellen und erh&ouml;ht die Entwicklungsgeschwindigkeit &rarr; mehr Fokus auf das Problem, welches gel&ouml;st werden will.</span></p><p class="c2 c0"><span></span></p><h2 class="c0"><a name="h.az34sguq1ub8"></a><span>Nachteile von interpretierten Sprachen</span></h2><p class="c0"><span>Nachteile auf interpretierte Sprache allgemein =&gt; Vor- / Nachteil im Realzeit-Bereich?</span></p><p class="c2 c0"><span></span></p><p class="c2 c0"><span></span></p><ol class="c1" start="1"><li class="c5 c0 c10"><span>Overhead</span></li></ol><p class="c0 c3"><span>Es kann eine langsamere Ausf&uuml;hrungszeit bei interpretierten Sprachen entstehen durch das h&ouml;here Abstraktionslevel und Vereinfachungen. Der Programmcode muss zur Laufzeit interpretiert bzw. compiliert werden; in regelm&auml;&szlig;igen Abst&auml;nden wird eine Garbage Collection vorgenommen, wodurch der eigentliche Programmablauf unterbrochen oder verlangsamt wird.</span></p><p class="c2 c0 c3"><span></span></p><p class="c0 c3"><span>Abgesehen von dem zus&auml;tzlichen Rechenaufwand gibt es einen Mehrbedarf an Arbeitsspeicher, zum einen ben&ouml;tigt der Interpreter (bzw. die virtuelle Maschine) zus&auml;tzlichen RAM f&uuml;r seinen Programmcode und seine Daten, zum anderen braucht der interpretierte Code ebenfalls mehr Speicher als beispielsweise C-Code.</span></p><p class="c2 c0 c3"><span></span></p><p class="c0 c3"><span>Die Ausf&uuml;hrung mittels des Interpreters f&uuml;hrt zu einer indirekteren Systeminteraktion, die Zugriffe auf das Betriebssystem (&ldquo;Syscalls&rdquo;) sind mit Overhead verbunden, da die Schnittstellen abstrahiert sind und der Interpreter die Aufrufe weiterleiten muss.</span></p><p class="c2 c0"><span></span></p><ol class="c1" start="1"><li class="c5 c0 c10"><span>dynamische Typisierung</span></li></ol><p class="c0 c3"><span>Die dynamische Typisierung kann allerdings auch ein Nachteil sein, da der Typ der Variablen unbekannt ist, was gerade in selten durchlaufenen Programmteilen, die eventuell auch nicht richtig getestet wurden, zu unerwartetem Fehlern f&uuml;hren kann. Die dynamische Typ&uuml;berpr&uuml;fung kostet nat&uuml;rlich auch Rechenaufwand zur Laufzeit, zudem fallen Optimierungsm&ouml;glichkeiten wie das direkte Einf&uuml;gen von Maschinencode statt eines Methoden- oder Funktionsaufrufs weg.</span></p><p class="c2 c0"><span></span></p><h2 class="c0"><a name="h.he19w2vpgfzi"></a><span>Problematiken im Realzeit-Bereich</span></h2><p class="c0"><span>Hard / Soft-Realtime</span></p><p class="c0"><span>Determinismus / WorstCase</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>So lange das System noch nicht an der Auslastungsgrenze ist (CPU-Rechenzeit), sollte es kein Problem darstellen, wenn die Software etwas langsamer l&auml;uft. Es kommt erst dann zu Problemen, wenn harte Echtzeit von N&ouml;ten ist, wenn der Garbage Collector anspringt und das Programm somit ins Stocken ger&auml;t -- zumal der GC nicht unbedingt zu deterministischen Zeiten anspringt, und auch nicht bekannt ist, wie lange er aktiv ist. Es ist somit sehr schwierig ein WortCase-Szenario zu erstellen und es m&uuml;ssen M&ouml;glichkeiten gesucht werden, wie man diese Problematiken in den Griff bekommen kann, so dass auch harte Realzeit realisiert werden kann.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>F&uuml;r Systeme die nur eine weiche Realzeit erfordern, sollten diese Beschr&auml;nkungen eher weniger das Problem sein. Was z.B. bei diversen &ldquo;echtzeit&rdquo; Web-Anwendungen der Fall ist.</span></p><h1 class="c6 c0"><a name="h.19l4h7i9qdj3"></a></h1><hr style="page-break-before:always;display:none;"><h1 class="c6 c0"><a name="h.w5c6a96cccku"></a></h1><h1 class="c0"><a name="h.fyv1xcpkqbra"></a><span>Beispiel Python</span></h1><p class="c0"><span>Allgemeine Infos (St&auml;rken, Schw&auml;chen, C-Anbindung, Herkunft)</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Python, dessen Name sich von der K&uuml;nstlergruppe Monty Python ableitet, ist um 1990 von dem Niederl&auml;nder Guido von Rossum entwickelt worden. In dieser Sprache wird auf die klare Sprachsyntax und gute Lesbarkeit sehr gro&szlig;en Wert gelegt. Geschaffen wurde die Sprache als Br&uuml;cke zwischen Shell-Skripten und C-Programmen.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Es handelt sich dabei um eine interpretierte, interaktive, Objekt-orientierte, funktionale Sprache, die aber auch ein einfaches Skript sein kann. Es gibt klar definierte Konzepte, wie Module f&uuml;r Namenr&auml;ume, dynamische Typesierung und simple, zugleich m&auml;chtige High-Level-Datenstrukturen wie Listen und Verzeichnisse (Dictionaries.) Zudem ist Python sehr leicht via C/C++ erweiterbar, somit k&ouml;nnen Wrapper um C-Programme gebaut werden, so dass ein erleichterter und komfortabler Zugriff via Python m&ouml;glich wird. So k&ouml;nnen bei Bedarf Programmzeilen in hart optimierten C-Code ausgelagert werden und Python genutzt werden -- gerade im eingebetteten Kontext durchaus ein Vorteil.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Durch die aktive Entwicklergemeinde hat sich eine sehr gro&szlig;e und m&auml;chtige Standard-Bibliothek entwickelt. [pyref &rarr; library.pdf] Was nicht zu untersch&auml;tzen ist, gerade weil dadurch die schon sehr portablen Python-Programme, auf diese Basis zur&uuml;ckgreifen k&ouml;nnen, die ohne Konfiguration auf anderen Systemen vornehmen zu m&uuml;ssen.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Aber Python ist auch sehr leicht &uuml;ber externe Bibliotheken erweiterbar. Zudem gibt es neben der gro&szlig;en Standard-Bibliothek sehr viele Pakete, die via pipy-Index zur Verf&uuml;gung stehen -- dieser Umfasst zur Zeit 21658 Pakete.[Fu&szlig;note auf pypi] Das Python-Ecosystem ist sehr umfassend!</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Es gibt eine Reihe an Python-Modulen f&uuml;r den komfortablen Ger&auml;tezugriff in Verbindung mit einem embedded Linux. Es handelt sich dabei um Wrapper f&uuml;r die Unix-Ger&auml;te-Dateien (/dev/*) [dipl]:</span></p><ol class="c1" start="1"><li class="c5 c0 c10"><span>socket: Teil der Standardbibliothek</span></li><li class="c5 c0 c10"><span>pyserial: F&uuml;r serielle Schnittstellen, ein Wrapper um termios.</span></li><li class="c5 c0 c10"><span>py-smbus: Wrapper um /dev/i2c-x</span></li><li class="c5 c0 c10"><span>py-spi: Wrapper um /dev/spidevX.Y. (X=bus, Y=client)</span></li><li class="c5 c0 c10"><span>py-pwm: Generische Pulsweiten Modulations API, die den Hardwarekanal ansprechen kann</span></li><li class="c5 c0 c10"><span>py-softpwm: Software PWM als Kernelmodul, Wrapper um /dev/softpwm [dipl]</span></li></ol><h2 class="c0"><a name="h.iqt0obegy8l8"></a><span>Architektur</span></h2><p class="c0"><span>Interpreter</span></p><p class="c0"><span>Paradigmen</span></p><p class="c0"><span>Dokumentation / Docstrings etc.</span></p><p class="c0"><span>wie ist es gedacht? wie funktioniert es?</span></p><p class="c0"><span>was ver&auml;ndet sich im eingebetteten Kontext?</span></p><h2 class="c0"><a name="h.e811rnb3jqns"></a><span>Garbage Collection</span></h2><p class="c0"><span>Garbage Collection (</span><span class="c9">GC</span><span>)</span><span>&nbsp;ist ein Prozess, der nicht mehr ben&ouml;tigter Speicher automatisch freigibt, so dass sich der Programmierer nicht mehr explizit darum k&uuml;mmern muss. Python macht intern in der unteren C-Ebene starken Gebrauch von mallock() und free(), daher braucht Python eine Strategie, um Speicherlecks zu vermeiden und verwendet dazu (a) </span><span class="c9">Referenzz&auml;hlen</span><span>&nbsp;und (b) optional einen GC der </span><span class="c9">Referenzzyklen aufsp&uuml;ren und brechen </span><span>kann. [pyref &rarr; S.81 reference.pdf]</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Erg&auml;nzung: Typen die keine Referenzen auf andere Objekte halten, oder lediglich Referenzen auf atomare Typen haben, m&uuml;ssen keine explizite GC unterst&uuml;tzen. [pyref &rarr; S138 c-api.pdf]</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Python </span><span class="c9">unterscheidet</span><span>&nbsp;zwischen (a) Referenzz&auml;hlen und (b) der automatischen optionalen GC [pyref &rarr; S13 extending.pdf]:</span></p><ol class="c1" start="1"><li class="c5 c0 c10"><span>(a) Referenzz&auml;hlen</span></li></ol><p class="c5 c0"><span>Jedes Python-Objekt h&auml;lt eine Variable, worin die Anzahl der Referenzen gez&auml;hlt wird, die von anderen Objekten in Besitz sind. Wenn eine Referenz auf ein Objekt in Besitz genommen werden will, muss es die Py_INCREF-Methode (Variable hochz&auml;hlen) des Objekts aufrufen werden. Wenn der Besitzer die Referenz verwerfen will, so wird Py_DECREF (Variable runterz&auml;hlen) aufgerufen. Sobald die Z&auml;hlvariable bei Null angekommen ist, wird das Objekt zerst&ouml;rt. Dieses Verhalten ist in der untersten Ebene bzw. C-Ebene der Sprache verdrahtet -- zumindest gilt das f&uuml;r die offizielle CPython-Referenzimplementierung.</span></p><p class="c5 c0"><span>Es gibt auch die M&ouml;glichkeit, dass Referenzen ausgeliehen werden k&ouml;nnen. Wenn das der Fall ist, wird kein Py_DECREF vom Leihenden aufgerufen (die Referenz kann vom Leihenden also nicht zerst&ouml;rt werden.) Vorteil: Der Leihende muss nicht die Verantwortung &uuml;ber die Zerst&ouml;rung der Referenz tragen; Nachteil: Der Leihende l&auml;uft Gefahr schon freiger&auml;umten Speicher zu verwenden.</span></p><ol class="c1" start="1"><li class="c5 c0 c10"><span>(b) Automatische GC</span></li></ol><p class="c5 c0"><span>Das was unter Python als automatischer GC gilt, ist optional und kann zur Lauftzeit deaktiviert werden. Dazu gibt es ein Interface, welches &uuml;ber das `gc`-Modul bereitgestellt wird, wo noch mehr Parameter eingestellt werden k&ouml;nnen, um das GC-Verhalten feinabzustimmen.</span></p><p class="c5 c0"><span>Die automatische GC bietet eine verz&ouml;gerte Erkennung von zyklisch zusammenh&auml;ngenden Garbage-Objekten, eben diese die nicht via Referenzz&auml;hlen aufgesp&uuml;rt werden k&ouml;nnen; z.B. wenn ein Objekt auf sich selbst eine Referenz h&auml;lt.</span></p><p class="c5 c0"><span>Die automatische GC ist also nur eine Erg&auml;nzung zum Referenzz&auml;hlen.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Der automatische, aber optionale, GC sorgt f&uuml;r ein nicht-deterministisches Verhalten (durch die verz&ouml;gerte Erkennung der Zyklen, die irgendwann auftreten kann), was gerade f&uuml;r harte Echtzeitbedingungen zu schwer zu prognostizierender Worst-Case-Analyse f&uuml;hrt. Wenn man den GC deaktiviert, muss jedoch darauf geachtet werden, dass keine Referenz-Zyklen auftreten, was ein potentielles Speicherleck hervorrufen kann. [pyref &rarr; S1084 library.pdf]</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Das Referenzz&auml;hlen kann in eine Worst-Case-Analyse besser aufgenommen werden, da sich das Problem ebenfalls auf der C-Ebene abspielen w&uuml;rde -- und es gibt durchaus realzeitf&auml;hige </span><span class="c9">Dynamic Storage Allocator</span><span>&nbsp;Algorithmen, die wiederum mehr vom Betriebssystem bzw. den verwendeten C-Bibliotheken abh&auml;ngen. Dieses Verhalten sollte und kann auch in die Worst-Case-Berechnungen mit einflie&szlig;en. [malloc]</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Wenn beim Programmstart lediglich statischer Speicher alloziert wird, so sollte die GC sowieso eine recht untergeordnete Rolle spielen.</span></p><h2 class="c0"><a name="h.eqz9t3s2se3t"></a><span>Setup-Szenarien</span></h2><p class="c0"><span>Embedded Linux</span></p><p class="c0"><span>python-on-a-chip</span></p><p class="c2 c0"><span></span></p><ol class="c1" start="1"><li class="c5 c0 c10"><span>IronPython</span></li></ol><p class="c0 c3"><span>IronPython ist eine open-source Implementierung von Python f&uuml;r das .NET Framework. Die in C# geschriebene Umgebung kann sowohl .NET- als auch Python-Bibliotheken verwenden und macht es den .NET-Programmiersprachen auf einfache Weise m&ouml;glich Python-Code auszuf&uuml;hren.</span></p><p class="c0 c3"><span>IronPython l&auml;sst sich auf einem Embedded Linux mittels der Mono Virtual Machine ausf&uuml;hren und bietet gute M&ouml;glichkeiten zum Debuggen. Der Mono Debugger unterst&uuml;tzt Remote-Debugging, wof&uuml;r nur ein kleiner Debug-Server auf dem eingebetteten System notwendig ist, und bietet so eine &Uuml;bersicht der Threads inklusive Stacktraces und Inhalten der Variablen, zudem lassen sich Breakpoints festlegen und die Anweisungen k&ouml;nnen schrittweise durchsprungen werden ([ironpython], Kap. 3).</span></p><p class="c0 c3"><span>Der von IronPython generierte CIL-Bytecode kann als .NET-Assembly gespeichert werden, was ein erneutes Ausf&uuml;hren durch die Virtual Machine um einiges beschleunigt.</span></p><p class="c2 c0"><span></span></p><p class="c2 c0"><span></span></p><h2 class="c0"><a name="h.nnr32lzcb28v"></a><span>Realzeitf&auml;higkeit</span></h2><p class="c0"><span>besondere Problematiken / Vorteile im eingebetten Kontext</span></p><p class="c0"><span>GC</span></p><p class="c0"><span>Umgang micht Stack (wo werden Variablen gespeichert? &ldquo;Umgehen&rdquo; der Garbage-Collection??)</span></p><h1 class="c6 c0"><a name="h.6xxkfqehcnjx"></a></h1><hr style="page-break-before:always;display:none;"><h1 class="c0 c6"><a name="h.lf0rti9dcfpa"></a></h1><h1 class="c0"><a name="h.yom4vsum15is"></a><span>Fazit</span></h1><hr style="page-break-before:always;display:none;"><h1 class="c6 c0"><a name="h.nc1982f6exwp"></a></h1><h1 class="c0"><a name="h.saghh5zbyul3"></a><span>Referenzen</span></h1><p class="c0"><span>[pyref] </span><span class="c4"><a class="c7" href="http://docs.python.org/ftp/python/doc/2.7.3/python-2.7.3-docs-pdf-a4.zip">http://docs.python.org/ftp/python/doc/2.7.3/python-2.7.3-docs-pdf-a4.zip</a></span></p><p class="c0"><span>[malloc] </span><span class="c4"><a class="c7" href="http://pub.mroot.net/Documents/Seminar-Realtime-malloc.pdf">http://pub.mroot.net/Documents/Seminar-Realtime-malloc.pdf</a></span></p><p class="c0"><span>[ironpython] &nbsp;</span><span class="c4"><a class="c7" href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?tp=&amp;arnumber=4976337">http://ieeexplore.ieee.org/xpl/articleDetails.jsp?tp=&amp;arnumber=4976337</a></span><span>&nbsp;</span></p><p class="c0"><span>[dipl] </span><span class="c4"><a class="c7" href="http://elk.informatik.fh-augsburg.de/da/da-49/da-thoms-cc.pdf">http://elk.informatik.fh-augsburg.de/da/da-49/da-thoms-cc.pdf</a></span><span>&nbsp;</span></p><p class="c2 c0"><span></span></p></body></html>