<html><head><title>ESYS</title><style type="text/css">ol{margin:0;padding:0}.c10{list-style-type:disc;margin:0;padding:0}.c6{max-width:508pt;background-color:#ffffff;padding:43.7pt 43.7pt 43.7pt 43.7pt}.c3{color:#1155cc;text-decoration:underline}.c8{color:inherit;text-decoration:inherit}.c7{margin-left:18pt}.c2{height:11pt}.c4{margin-left:36pt}.c9{padding-left:0pt}.c5{height:18pt}.c0{direction:ltr}.c1{margin-left:34.5pt}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Arial";padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#666666;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:10pt;font-family:"Arial";padding-bottom:2pt}</style></head><body class="c6"><h1 class="c5 c0"><a name="h.ytn0txyu13hj"></a></h1><p class="c7 c0"><span class="c3"><a class="c8" href="#h.7r0qyqe2ek34">Vorwort</a></span></p><p class="c7 c0"><span class="c3"><a class="c8" href="#h.2izi2w3k7sz0">Interpretierte Sprachen und Realzeit</a></span></p><p class="c4 c0"><span class="c3"><a class="c8" href="#h.6ng1wyu6xr1r">Definitionen</a></span></p><p class="c4 c0"><span class="c3"><a class="c8" href="#h.y2vemi43u9wr">Vorteile von interpretierten Sprachen</a></span></p><p class="c4 c0"><span class="c3"><a class="c8" href="#h.az34sguq1ub8">Nachteile von interpretierten Sprachen</a></span></p><p class="c4 c0"><span class="c3"><a class="c8" href="#h.he19w2vpgfzi">Problematiken im Realzeit-Bereich</a></span></p><p class="c7 c0"><span class="c3"><a class="c8" href="#h.fyv1xcpkqbra">Beispiel Python</a></span></p><p class="c4 c0"><span class="c3"><a class="c8" href="#h.iqt0obegy8l8">Architektur</a></span></p><p class="c4 c0"><span class="c3"><a class="c8" href="#h.eqz9t3s2se3t">Setup-Szenarien</a></span></p><p class="c4 c0"><span class="c3"><a class="c8" href="#h.nnr32lzcb28v">Realzeitf&auml;higkeit</a></span></p><p class="c0 c7"><span class="c3"><a class="c8" href="#h.p29bvm5fnjg7">Fazit</a></span></p><p class="c2 c0"><span></span></p><h1 class="c0 c5"><a name="h.bwp6eesnpua3"></a></h1><p class="c2 c0"><span></span></p><hr style="page-break-before:always;display:none;"><h1 class="c5 c0"><a name="h.y4vr7jx1fk1s"></a></h1><h1 class="c0"><a name="h.7r0qyqe2ek34"></a><span>Vorwort</span></h1><p class="c0"><span>Eingebettete Systeme werden immer leistungsf&auml;higer und dadurch ergibt sich die M&ouml;glichkeit weniger hardwarenah zu programmieren beziehungsweise abstrakter zu werden -- denn dies ist f&uuml;r gew&ouml;hnlich mit etwas Overhead beziehungsweise erh&ouml;htem Rechenaufwand verbunden, aber zugleich eleganter und schneller zu entwickeln.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Gerade interpretierte Programmiersprachen sind dazu geschaffen, um schnell eleganten Programmcode zu schreiben, aber meistens leidet darunter die Ausf&uuml;hrungsgeschwindigkeit aufgrund von diversen &ldquo;High-Level&rdquo;-Funktionen.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Ob solche Programmiersprachen auch realzeitf&auml;hig sind, soll in dieser Arbeit gekl&auml;rt werden. Dazu werden deren Vor- und Nachteile im Realzeit-Kontext betrachtet und spezielle Problematiken aufgezeigt.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Python ist eine sehr beliebte Sprache geworden und wird mittlerweile auf nahezu jeder Standard-UNIX-Distribution mit ausgeliefert und bietet sehr viele und flexible M&ouml;glichkeiten, wie eine gro&szlig;e Standard-Bibliothek und Erweiterbarkeit via C/C++ und bietet sich darum als Beispielssprache an.</span></p><p class="c2 c0"><span></span></p><hr style="page-break-before:always;display:none;"><p class="c2 c0"><span></span></p><p class="c2 c0"><span></span></p><h1 class="c0"><a name="h.2izi2w3k7sz0"></a><span>Interpretierte Sprachen und Realzeit</span></h1><h2 class="c0"><a name="h.6ng1wyu6xr1r"></a><span>Definitionen</span></h2><p class="c0"><span>Interpretierte Sprachen sind Programmiersprachen, deren Quellcode zur Laufzeit durch einen Interpreter eingelesen, analysiert und ausgef&uuml;hrt wird. Dadurch erm&ouml;glichen sie ein erleichtertes Programmieren, da sie viel Komplexit&auml;t verstecken und einen h&ouml;heren Abstraktionsgrad erm&ouml;glichen -- so m&uuml;ssen zum Beispiel Zeiger nicht mehr explizit verwaltet werden, oder Objekte werden von einem Garbage Collector automatisch aufger&auml;umt.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Realzeit bedeutet, dass das System innerhalb definierter Zeitspannen zu reagieren hat. Das bedeutet also, dass insbesondere die Software innerhalb dieser Zeitspanne ihre Berechnungen erledigt haben muss.</span></p><p class="c0"><span>Wenn ein System oder Prozess weiche Realzeitanforderungen hat, kann auch mal eine Frist, also die Reaktion war au&szlig;erhalb der Zeitspanne, verpasst werden.</span></p><p class="c0"><span>Hat ein System allerdings harte Echtzeitanforderungen, so darf es um keinen Preis die Frist verpassen, da sonst die Folgen fatal w&auml;ren. Beispielsweise ein Airbag, der erst nach dem Unfall ausl&ouml;st, w&auml;re unbrauchbar.</span></p><p class="c2 c0"><span></span></p><h2 class="c0"><a name="h.y2vemi43u9wr"></a><span>Vorteile von interpretierten Sprachen</span></h2><p class="c0"><span>Vorteile auf interpretierte Sprache allgemein =&gt; Vor- / Nachteil im Realzeit-Bereich?</span></p><p class="c0"><span>unter anderem GC</span></p><p class="c2 c0"><span></span></p><ol class="c10" start="1"><li class="c4 c0 c9"><span>erleichterte Programmierung</span></li></ol><p class="c4 c0"><span>Was interpretierte Sprachen auszeichnet ist ihre Wendigkeit und die daraus resultierende k&uuml;rzere Entwicklungszeit der Software. Somit kann Software schneller und einfacher umgebaut werden, aber auch leichter getestet werden. Daher sind interpretierte Sprachen wunderbar f&uuml;r rapide Entwicklung geeignet, weshalb diese Sprachen gerade im Bereich Web sehr verbreitet sind.</span></p><p class="c2 c4 c0"><span></span></p><p class="c4 c0"><span>Einer der Gr&uuml;nde ist die dynamische Typisierung, die die meisten interpretierten Sprachen einsetzen: Es muss nicht mehr &uuml;ber alle Typen nachgedacht werden bzw. man f&auml;llt nicht mehr so leicht in diverse Fallen, die durch statische Typisierung entstehen. (Dadurch entsteht aber auch ein gewisser Overhead, wodurch diese Sprachen deutlich langsamer sein k&ouml;nnen.)</span></p><p class="c2 c4 c0"><span></span></p><p class="c4 c0"><span>Es gibt viele komfortable und durch die Sprache vordefinierte (u.U. auch sehr m&auml;chtige) Konstrukte, die es erm&ouml;glichen eleganten Code zu schreiben, welcher kompakt und ausdrucksstark ist. Die Sprache hat somit ihre eigenen Paradigmen, welche eine hohe Abstraktion bieten.</span></p><p class="c0 c4"><span>Dank solcher Abstraktionen, muss sich der Programmierer kaum &nbsp;noch Gedanken &uuml;ber Zeiger und ihre Verwaltung machen, das &uuml;bernimmt alles der Interpreter bzw. die virtuelle Maschine der Sprache.</span></p><p class="c2 c4 c0"><span></span></p><p class="c4 c0"><span>Kein Compilieren, kein Binden, interaktives Debugging.</span></p><p class="c2 c4 c0"><span></span></p><p class="c4 c0"><span>Der Programmierer arbeitet also mehr problemorientiert, als an den Problemen mit der Programmiersprache zu k&auml;mpfen.</span></p><p class="c2 c0"><span></span></p><ol class="c10" start="1"><li class="c4 c9 c0"><span>leichte Portierbarkeit</span></li></ol><p class="c4 c0"><span>Interpretierte Sprachen lassen sich relativ leicht auf neue Architekturen portieren, denn lediglich der Interpreter muss angepasst werden, der Quellcode der Programme bleibt unber&uuml;hrt.</span></p><p class="c2 c0"><span></span></p><ol class="c10" start="1"><li class="c4 c9 c0"><span>Garbage Collection</span></li></ol><p class="c4 c0"><span>Die Garbage Collection ist eine der High-Level Abstraktionen die vom Interpreter bzw. der virtuellen Maschine der Programmiersprache angeboten werden. Wenn eine GC angeboten wird, bedeutet das f&uuml;r den Programmierer, dass er sich nicht mehr um die Speicherallokierung und Deallokierung k&uuml;mmern muss. Das minimiert potentielle Fehlerquellen und erh&ouml;ht die Entwicklungsgeschwindigkeit &rarr; mehr Fokus auf das Problem, welches gel&ouml;st werden will.</span></p><p class="c2 c0"><span></span></p><h2 class="c0"><a name="h.az34sguq1ub8"></a><span>Nachteile von interpretierten Sprachen</span></h2><p class="c0"><span>Nachteile auf interpretierte Sprache allgemein =&gt; Vor- / Nachteil im Realzeit-Bereich?</span></p><p class="c2 c0"><span></span></p><p class="c2 c0"><span></span></p><ol class="c10" start="1"><li class="c4 c9 c0"><span>Overhead</span></li></ol><p class="c0 c1"><span>Es kann eine langsamere Ausf&uuml;hrungszeit bei interpretierten Sprachen entstehen durch das h&ouml;here Abstraktionslevel und Vereinfachungen. Der Programmcode muss zur Laufzeit interpretiert bzw. compiliert werden; in regelm&auml;&szlig;igen Abst&auml;nden wird eine Garbage Collection vorgenommen, wodurch der eigentliche Programmablauf unterbrochen oder verlangsamt wird.</span></p><p class="c2 c0 c1"><span></span></p><p class="c0 c1"><span>Abgesehen von dem zus&auml;tzlichen Rechenaufwand gibt es einen Mehrbedarf an Arbeitsspeicher, zum einen ben&ouml;tigt der Interpreter (bzw. die virtuelle Maschine) zus&auml;tzlichen RAM f&uuml;r seinen Programmcode und seine Daten, zum anderen braucht der interpretierte Code ebenfalls mehr Speicher als beispielsweise C-Code.</span></p><p class="c2 c0 c1"><span></span></p><p class="c0 c1"><span>Die Ausf&uuml;hrung mittels des Interpreters f&uuml;hrt zu einer indirekteren Systeminteraktion, die Zugriffe auf das Betriebssystem (&ldquo;Syscalls&rdquo;) sind mit Overhead verbunden, da die Schnittstellen abstrahiert sind und der Interpreter die Aufrufe weiterleiten muss.</span></p><p class="c2 c0"><span></span></p><ol class="c10" start="1"><li class="c4 c9 c0"><span>dynamische Typisierung</span></li></ol><p class="c0 c1"><span>Die dynamische Typisierung kann allerdings auch ein Nachteil sein, da der Typ der Variablen unbekannt ist, was gerade in selten durchlaufenen Programmteilen, die eventuell auch nicht richtig getestet wurden, zu unerwartetem Fehlern f&uuml;hren kann. Die dynamische Typ&uuml;berpr&uuml;fung kostet nat&uuml;rlich auch Rechenaufwand zur Laufzeit, zudem fallen Optimierungsm&ouml;glichkeiten wie das direkte Einf&uuml;gen von Maschinencode statt eines Methoden- oder Funktionsaufrufs weg.</span></p><p class="c2 c0"><span></span></p><h2 class="c0"><a name="h.he19w2vpgfzi"></a><span>Problematiken im Realzeit-Bereich</span></h2><p class="c0"><span>Hard / Soft-Realtime</span></p><p class="c0"><span>Determinismus / WorstCase</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>So lange das System noch nicht an der Auslastungsgrenze ist (CPU-Rechenzeit), sollte es kein Problem darstellen, wenn die Software etwas langsamer l&auml;uft. Es kommt erst dann zu Problemen, wenn harte Echtzeit von N&ouml;ten ist, wenn der Garbage Collector anspringt und das Programm somit ins Stocken ger&auml;t -- zumal der GC nicht unbedingt zu deterministischen Zeiten anspringt, und auch nicht bekannt ist, wie lange er aktiv ist. Es ist somit sehr schwierig ein WortCase-Szenario zu erstellen und es m&uuml;ssen M&ouml;glichkeiten gesucht werden, wie man diese Problematiken in den Griff bekommen kann, so dass auch harte Realzeit realisiert werden kann.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>F&uuml;r Systeme die nur eine weiche Realzeit erfordern, sollten diese Beschr&auml;nkungen eher weniger das Problem sein. Was z.B. bei diversen &ldquo;echtzeit&rdquo; Web-Anwendungen der Fall ist.</span></p><h1 class="c5 c0"><a name="h.19l4h7i9qdj3"></a></h1><hr style="page-break-before:always;display:none;"><h1 class="c5 c0"><a name="h.w5c6a96cccku"></a></h1><h1 class="c0"><a name="h.fyv1xcpkqbra"></a><span>Beispiel Python</span></h1><p class="c0"><span>Allgemeine Infos (St&auml;rken, Schw&auml;chen, C-Anbindung, Herkunft)</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Python, dessen Name sich von der K&uuml;nstlergruppe Monty Python ableitet, ist um 1990 von dem Niederl&auml;nder Guido von Rossum entwickelt worden. In dieser Sprache wird auf die klare Sprachsyntax und gute Lesbarkeit sehr gro&szlig;en Wert gelegt.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Es handelt sich dabei um eine interpretierte, interaktive, Objekt-orientierte, funktionale Sprache, die aber auch ein einfaches Skript sein kann. Es gibt klar definierte Konzepte, wie Module f&uuml;r Namenr&auml;ume, dynamische Typesierung und simple, zugleich m&auml;chtige High-Level-Datenstrukturen wie Listen und Verzeichnisse (Dictionaries.) Zudem ist Python sehr leicht via C/C++ erweiterbar, somit k&ouml;nnen Wrapper um C-Programme gebaut werden, so dass ein erleichterter und komfortabler Zugriff via Python m&ouml;glich wird. So k&ouml;nnen bei Bedarf Programmzeilen in hart optimierten C-Code ausgelagert werden und Python genutzt werden -- gerade im eingebetteten Kontext durchaus ein Vorteil.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>Durch die aktive Entwicklergemeinde hat sich eine sehr gro&szlig;e und m&auml;chtige Standard-Bibliothek entwickelt. Was nicht zu untersch&auml;tzen ist, gerade weil dadurch die schon sehr portablen Python-Programme, auf diese Basis zur&uuml;ckgreifen k&ouml;nnen, die ohne Konfiguration auf anderen Systemen vornehmen zu m&uuml;ssen.</span></p><p class="c0 c2"><span></span></p><p class="c0"><span>Aber Python ist auch sehr leicht &uuml;ber externe Bibliotheken erweiterbar. Zudem gibt es neben der gro&szlig;en Standard-Bibliothek sehr viele Pakete, die via pipy-Index zur Verf&uuml;gung stehen -- dieser Umfasst zur Zeit 21658 Pakete. Das Python-Ecosystem ist sehr umfassend!</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>externe Libraries, Ger&auml;tezugriffe (I2C, SMBus)</span></p><p class="c2 c0"><span></span></p><h2 class="c0"><a name="h.iqt0obegy8l8"></a><span>Architektur</span></h2><p class="c0"><span>Interpreter</span></p><p class="c0"><span>Paradigmen</span></p><p class="c0"><span>Dokumentation / Docstrings etc.</span></p><p class="c0"><span>wie ist es gedacht? wie funktioniert es?</span></p><p class="c0"><span>was ver&auml;ndet sich im eingebetteten Kontext?</span></p><p class="c2 c0"><span></span></p><h2 class="c0"><a name="h.eqz9t3s2se3t"></a><span>Setup-Szenarien</span></h2><p class="c0"><span>Embedded Linux</span></p><p class="c0"><span>python-on-a-chip</span></p><p class="c2 c0"><span></span></p><h2 class="c0"><a name="h.nnr32lzcb28v"></a><span>Realzeitf&auml;higkeit</span></h2><p class="c0"><span>besondere Problematiken / Vorteile im eingebetten Kontext</span></p><p class="c0"><span>GC</span></p><p class="c0"><span>Umgang micht Stack (wo werden Variablen gespeichert? &ldquo;Umgehen&rdquo; der Garbage-Collection??)</span></p><h1 class="c5 c0"><a name="h.6xxkfqehcnjx"></a></h1><hr style="page-break-before:always;display:none;"><h1 class="c5 c0"><a name="h.lf0rti9dcfpa"></a></h1><h1 class="c0"><a name="h.p29bvm5fnjg7"></a><span>Fazit</span></h1><p class="c2 c0"><span></span></p></body></html>